/**
 * Artifact Store Tests
 *
 * Tests for InMemoryArtifactStore and ArtifactStoreWithEvents decorator
 */

import { Subject } from 'rxjs';
import { beforeEach, describe, expect, it } from 'vitest';
import type { ArtifactUpdateEvent } from '../src/core/types';
import {
  ArtifactStoreWithEvents,
  SubjectEventEmitter,
  InMemoryArtifactStore,
} from '../src/stores/artifacts';

describe('InMemoryArtifactStore', () => {
  let store: InMemoryArtifactStore;

  beforeEach(() => {
    store = new InMemoryArtifactStore();
  });

  describe('createFileArtifact', () => {
    it('should create a file artifact with provided ID', async () => {
      const artifactId = await store.createFileArtifact({
        artifactId: 'my-artifact-1',
        taskId: 'task-1',
        contextId: 'ctx-1',
        name: 'Test Artifact',
        description: 'A test artifact',
      });

      expect(artifactId).toBe('my-artifact-1');
      expect(typeof artifactId).toBe('string');

      const artifact = await store.getArtifact(artifactId);
      expect(artifact).toBeTruthy();
      expect(artifact?.artifactId).toBe('my-artifact-1');
      expect(artifact?.type).toBe('file');
      expect(artifact?.name).toBe('Test Artifact');
      expect(artifact?.description).toBe('A test artifact');
      expect(artifact?.taskId).toBe('task-1');
      expect(artifact?.contextId).toBe('ctx-1');
      expect(artifact?.status).toBe('building');
      if (artifact?.type === 'file') {
        expect(artifact.chunks).toEqual([]);
      }
    });

    it('should track artifact by task ID', async () => {
      const artifactId = await store.createFileArtifact({
        artifactId: 'artifact-2',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      const taskArtifacts = await store.getTaskArtifacts('task-1');
      expect(taskArtifacts).toContain(artifactId);
    });

    it('should track artifact by context ID', async () => {
      const artifactId = await store.createFileArtifact({
        artifactId: 'artifact-3',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      const contextArtifacts = await store.queryArtifacts({ contextId: 'ctx-1' });
      expect(contextArtifacts).toContain(artifactId);
    });
  });

  describe('appendPart', () => {
    it('should append text part to artifact', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-4',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Hello, world!',
      });

      const artifact = await store.getArtifact(artifactId);
      expect(artifact?.parts).toHaveLength(1);
      expect(artifact?.parts[0]).toMatchObject({
        index: 0,
        kind: 'text',
        content: 'Hello, world!',
      });
      expect(artifact?.status).toBe('building');
    });

    it('should mark artifact as complete on last chunk', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-5',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'Final chunk',
        },
        true // isLastChunk
      );

      const artifact = await store.getArtifact(artifactId);
      expect(artifact?.status).toBe('complete');
      expect(artifact?.isLastChunk).toBe(true);
      expect(artifact?.completedAt).toBeTruthy();
    });

    it('should handle multiple parts', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-6',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Part 1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Part 2',
      });

      await store.appendPart(artifactId, {
        kind: 'data',
        data: { value: 42 },
      });

      const parts = await store.getArtifactParts(artifactId);
      expect(parts).toHaveLength(3);
      expect(parts[0].content).toBe('Part 1');
      expect(parts[1].content).toBe('Part 2');
      expect(parts[2].data).toEqual({ value: 42 });
    });

    it('should throw error for non-existent artifact', async () => {
      await expect(
        store.appendPart('non-existent', {
          kind: 'text',
          content: 'test',
        })
      ).rejects.toThrow('Artifact not found');
    });
  });

  describe('replacePart', () => {
    it('should replace an existing part', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-7',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Original',
      });

      await store.replacePart(artifactId, 0, {
        kind: 'text',
        content: 'Replaced',
      });

      const parts = await store.getArtifactParts(artifactId);
      expect(parts[0].content).toBe('Replaced');
    });

    it('should throw error for invalid part index', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-8',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await expect(
        store.replacePart(artifactId, 5, {
          kind: 'text',
          content: 'test',
        })
      ).rejects.toThrow('Invalid part index');
    });
  });

  describe('queryArtifacts', () => {
    it('should query artifacts by context', async () => {
      const id1 = await store.createArtifact({
        artifactId: 'artifact-9',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });
      const id2 = await store.createArtifact({
        artifactId: 'artifact-10',
        taskId: 'task-2',
        contextId: 'ctx-1',
      });
      await store.createArtifact({
        artifactId: 'artifact-11',
        taskId: 'task-3',
        contextId: 'ctx-2',
      });

      const artifacts = await store.queryArtifacts({ contextId: 'ctx-1' });
      expect(artifacts).toHaveLength(2);
      expect(artifacts).toContain(id1);
      expect(artifacts).toContain(id2);
    });

    it('should filter by context and task', async () => {
      const id1 = await store.createArtifact({
        artifactId: 'artifact-12',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });
      await store.createArtifact({
        artifactId: 'artifact-13',
        taskId: 'task-2',
        contextId: 'ctx-1',
      });

      const artifacts = await store.queryArtifacts({
        contextId: 'ctx-1',
        taskId: 'task-1',
      });
      expect(artifacts).toHaveLength(1);
      expect(artifacts[0]).toBe(id1);
    });
  });

  describe('getArtifactByContext', () => {
    it('should return artifact if context matches', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-14',
        taskId: 'task-1',
        contextId: 'ctx-1',
        name: 'Test',
      });

      const artifact = await store.getArtifactByContext('ctx-1', artifactId);
      expect(artifact).toBeTruthy();
      expect(artifact?.name).toBe('Test');
    });

    it('should return null if context does not match', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-15',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      const artifact = await store.getArtifactByContext('ctx-2', artifactId);
      expect(artifact).toBeNull();
    });
  });

  describe('getArtifactContent', () => {
    it('should return combined text content', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-16',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Hello, ',
      });
      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'world!',
      });

      const content = await store.getArtifactContent(artifactId);
      expect(content).toBe('Hello, world!');
    });

    it('should return data for single data part', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-17',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'data',
        data: { result: 42, status: 'ok' },
      });

      const content = await store.getArtifactContent(artifactId);
      expect(content).toEqual({ result: 42, status: 'ok' });
    });

    it('should return structured representation for mixed parts', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-18',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Text part',
      });
      await store.appendPart(artifactId, {
        kind: 'data',
        data: { value: 42 },
      });

      const content = await store.getArtifactContent(artifactId);
      expect(content).toHaveProperty('parts');
      expect((content as { parts: unknown[] }).parts).toHaveLength(2);
    });
  });

  describe('deleteArtifact', () => {
    it('should delete artifact and clean up indexes', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-19',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.deleteArtifact(artifactId);

      const artifact = await store.getArtifact(artifactId);
      expect(artifact).toBeNull();

      const taskArtifacts = await store.getTaskArtifacts('task-1');
      expect(taskArtifacts).not.toContain(artifactId);

      const contextArtifacts = await store.queryArtifacts({ contextId: 'ctx-1' });
      expect(contextArtifacts).not.toContain(artifactId);
    });
  });
});

describe('ArtifactStoreWithEvents', () => {
  let baseStore: InMemoryArtifactStore;
  let eventSubject: Subject<ArtifactUpdateEvent>;
  let store: ArtifactStoreWithEvents;
  let events: ArtifactUpdateEvent[];

  beforeEach(() => {
    baseStore = new InMemoryArtifactStore();
    eventSubject = new Subject<ArtifactUpdateEvent>();
    store = new ArtifactStoreWithEvents(baseStore, new SubjectEventEmitter(eventSubject));
    events = [];

    eventSubject.subscribe((event) => events.push(event));
  });

  describe('createArtifact', () => {
    it('should emit artifact-update event on creation', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-20',
        taskId: 'task-1',
        contextId: 'ctx-1',
        name: 'Test Artifact',
      });

      expect(events).toHaveLength(1);
      expect(events[0]).toMatchObject({
        kind: 'artifact-update',
        taskId: 'task-1',
        contextId: 'ctx-1',
        append: false,
        lastChunk: false,
      });
      expect(events[0].artifact.artifactId).toBe(artifactId);
      expect(events[0].artifact.name).toBe('Test Artifact');
      expect(events[0].artifact.parts).toEqual([]);
    });
  });

  describe('appendPart', () => {
    it('should emit artifact-update event with appended part', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-21',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      events.length = 0; // Clear creation event

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Hello',
      });

      expect(events).toHaveLength(1);
      expect(events[0]).toMatchObject({
        kind: 'artifact-update',
        taskId: 'task-1',
        contextId: 'ctx-1',
        append: true,
        lastChunk: false,
      });
      expect(events[0].artifact.parts).toHaveLength(1);
      expect(events[0].artifact.parts[0]).toMatchObject({
        kind: 'text',
        text: 'Hello',
      });
    });

    it('should emit lastChunk=true on final part', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-23',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      events.length = 0;

      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'Final',
        },
        true
      );

      expect(events[0].lastChunk).toBe(true);
    });

    it('should emit only latest part for append operations', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-24',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Part 1',
      });

      events.length = 0;

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Part 2',
      });

      // Should only include the latest part
      expect(events[0].artifact.parts).toHaveLength(1);
      expect(events[0].artifact.parts[0]).toMatchObject({
        kind: 'text',
        text: 'Part 2',
      });
    });
  });

  describe('replacePart', () => {
    it('should emit artifact-update event with all parts', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-25',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Original',
      });

      events.length = 0;

      await store.replacePart(artifactId, 0, {
        kind: 'text',
        content: 'Replaced',
      });

      expect(events).toHaveLength(1);
      expect(events[0]).toMatchObject({
        kind: 'artifact-update',
        append: false, // Replace is not append
        lastChunk: false,
      });
      // For replace, send all parts
      expect(events[0].artifact.parts).toHaveLength(1);
      expect(events[0].artifact.parts[0]).toMatchObject({
        kind: 'text',
        text: 'Replaced',
      });
    });
  });

  describe('A2A part conversion', () => {
    it('should convert text parts correctly', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-26',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      events.length = 0;

      await store.appendPart(artifactId, {
        kind: 'text',
        content: 'Test text',
        metadata: { format: 'markdown' },
      });

      expect(events[0].artifact.parts[0]).toMatchObject({
        kind: 'text',
        text: 'Test text',
        metadata: { format: 'markdown' },
      });
    });

    it('should convert data parts correctly', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-27',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      events.length = 0;

      await store.appendPart(artifactId, {
        kind: 'data',
        data: { result: 42, status: 'success' },
        metadata: { source: 'calculation' },
      });

      expect(events[0].artifact.parts[0]).toMatchObject({
        kind: 'data',
        data: { result: 42, status: 'success' },
        metadata: { source: 'calculation' },
      });
    });

    it('should convert file parts with metadata', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'artifact-28',
        taskId: 'task-1',
        contextId: 'ctx-1',
      });

      events.length = 0;

      await store.appendPart(artifactId, {
        kind: 'file',
        content: 'base64content',
        metadata: {
          fileName: 'test.png',
          mimeType: 'image/png',
        },
      });

      expect(events[0].artifact.parts[0]).toMatchObject({
        kind: 'file',
        file: {
          name: 'test.png',
          mimeType: 'image/png',
          bytes: 'base64content',
        },
      });
    });
  });
});
