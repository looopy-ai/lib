/**
 * Tests for Internal Event Artifact Store
 *
 * Phase 4: Artifact Event Implementation
 * Tests file-write and data-write event emission from artifact operations
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  InternalEventArtifactStore,
  type InternalEventEmitter,
  InMemoryArtifactStore,
} from '../src/stores/artifacts';
import type { InternalEvent } from '../src/events';

describe('InternalEventArtifactStore', () => {
  let store: InternalEventArtifactStore;
  let delegate: InMemoryArtifactStore;
  let emittedEvents: InternalEvent[];
  let eventEmitter: InternalEventEmitter;

  beforeEach(() => {
    delegate = new InMemoryArtifactStore();
    emittedEvents = [];
    eventEmitter = {
      emit: (event: InternalEvent) => {
        emittedEvents.push(event);
      },
    };
    store = new InternalEventArtifactStore({
      delegate,
      eventEmitter,
    });
  });

  describe('File-Write Events', () => {
    it('should emit file-write event when appending text part', async () => {
      // Create artifact
      const artifactId = await store.createArtifact({
        artifactId: 'art-1',
        taskId: 'task-1',
        contextId: 'ctx-1',
        name: 'output.txt',
      });

      // Append text part
      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'Hello, world!',
        },
        false
      );

      // Should have emitted one file-write event
      expect(emittedEvents).toHaveLength(1);
      const event = emittedEvents[0];

      expect(event.kind).toBe('file-write');
      if (event.kind === 'file-write') {
        expect(event.artifactId).toBe('art-1');
        expect(event.taskId).toBe('task-1');
        expect(event.contextId).toBe('ctx-1');
        expect(event.data).toBe('Hello, world!');
        expect(event.index).toBe(0);
        expect(event.complete).toBe(false);
        expect(event.name).toBe('output.txt');
        expect(event.mimeType).toBe('text/plain');
      }
    });

    it('should emit multiple file-write events for chunked streaming', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-2',
        taskId: 'task-2',
        contextId: 'ctx-2',
        name: 'large-file.txt',
      });

      // Append first chunk
      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'Chunk 1',
        },
        false
      );

      // Append second chunk
      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'Chunk 2',
        },
        false
      );

      // Append final chunk
      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'Chunk 3',
        },
        true // isLastChunk
      );

      // Should have emitted 3 file-write events
      expect(emittedEvents).toHaveLength(3);

      // First chunk should have metadata
      const firstEvent = emittedEvents[0];
      expect(firstEvent.kind).toBe('file-write');
      if (firstEvent.kind === 'file-write') {
        expect(firstEvent.data).toBe('Chunk 1');
        expect(firstEvent.index).toBe(0);
        expect(firstEvent.complete).toBe(false);
        expect(firstEvent.name).toBe('large-file.txt');
        expect(firstEvent.mimeType).toBe('text/plain');
      }

      // Second chunk
      const secondEvent = emittedEvents[1];
      expect(secondEvent.kind).toBe('file-write');
      if (secondEvent.kind === 'file-write') {
        expect(secondEvent.data).toBe('Chunk 2');
        expect(secondEvent.index).toBe(1);
        expect(secondEvent.complete).toBe(false);
        expect(secondEvent.name).toBeUndefined(); // Not first chunk
        expect(secondEvent.mimeType).toBeUndefined(); // Not first chunk
      }

      // Final chunk
      const thirdEvent = emittedEvents[2];
      expect(thirdEvent.kind).toBe('file-write');
      if (thirdEvent.kind === 'file-write') {
        expect(thirdEvent.data).toBe('Chunk 3');
        expect(thirdEvent.index).toBe(2);
        expect(thirdEvent.complete).toBe(true); // Last chunk
        expect(thirdEvent.name).toBeUndefined();
      }
    });

    it('should emit file-write event for file parts', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-3',
        taskId: 'task-3',
        contextId: 'ctx-3',
        name: 'image.png',
        mimeType: 'image/png',
      });

      // Append file part
      await store.appendPart(
        artifactId,
        {
          kind: 'file',
          content: 'base64-encoded-data',
          metadata: {
            fileName: 'image.png',
            mimeType: 'image/png',
          },
        },
        true
      );

      expect(emittedEvents).toHaveLength(1);
      const event = emittedEvents[0];

      expect(event.kind).toBe('file-write');
      if (event.kind === 'file-write') {
        expect(event.data).toBe('base64-encoded-data');
        expect(event.mimeType).toBe('image/png');
        expect(event.name).toBe('image.png');
        expect(event.complete).toBe(true);
      }
    });

    it('should handle file parts with file references', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-4',
        taskId: 'task-4',
        contextId: 'ctx-4',
        name: 'document.pdf',
      });

      await store.appendPart(
        artifactId,
        {
          kind: 'file',
          fileReference: {
            storageKey: 's3://bucket/file.pdf',
            size: 1024,
          },
          metadata: {
            mimeType: 'application/pdf',
          },
        },
        true
      );

      expect(emittedEvents).toHaveLength(1);
      const event = emittedEvents[0];

      expect(event.kind).toBe('file-write');
      if (event.kind === 'file-write') {
        expect(event.data).toBe('[FILE:s3://bucket/file.pdf]');
        expect(event.mimeType).toBe('application/pdf');
      }
    });
  });

  describe('Data-Write Events', () => {
    it('should emit data-write event when appending data part', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-5',
        taskId: 'task-5',
        contextId: 'ctx-5',
        name: 'config.json',
      });

      const configData = {
        setting1: 'value1',
        setting2: 42,
        nested: {
          key: 'value',
        },
      };

      await store.appendPart(
        artifactId,
        {
          kind: 'data',
          data: configData,
        },
        false
      );

      expect(emittedEvents).toHaveLength(1);
      const event = emittedEvents[0];

      expect(event.kind).toBe('data-write');
      if (event.kind === 'data-write') {
        expect(event.artifactId).toBe('art-5');
        expect(event.taskId).toBe('task-5');
        expect(event.contextId).toBe('ctx-5');
        expect(event.data).toEqual(configData);
        expect(event.name).toBe('config.json');
      }
    });

    it('should emit data-write event without metadata on subsequent updates', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-6',
        taskId: 'task-6',
        contextId: 'ctx-6',
        name: 'data.json',
        description: 'Test data',
      });

      // First data write
      await store.appendPart(
        artifactId,
        {
          kind: 'data',
          data: { version: 1 },
        },
        false
      );

      // Second data write (update)
      await store.appendPart(
        artifactId,
        {
          kind: 'data',
          data: { version: 2, updated: true },
        },
        false
      );

      expect(emittedEvents).toHaveLength(2);

      // First event should have metadata
      const firstEvent = emittedEvents[0];
      expect(firstEvent.kind).toBe('data-write');
      if (firstEvent.kind === 'data-write') {
        expect(firstEvent.name).toBe('data.json');
        expect(firstEvent.description).toBe('Test data');
      }

      // Second event should not have name/description (not first chunk)
      const secondEvent = emittedEvents[1];
      expect(secondEvent.kind).toBe('data-write');
      if (secondEvent.kind === 'data-write') {
        expect(secondEvent.data).toEqual({ version: 2, updated: true });
        expect(secondEvent.name).toBeUndefined();
        expect(secondEvent.description).toBeUndefined();
      }
    });

    it('should emit data-write event when replacing data part', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-7',
        taskId: 'task-7',
        contextId: 'ctx-7',
        name: 'state.json',
      });

      // Initial data
      await store.appendPart(
        artifactId,
        {
          kind: 'data',
          data: { state: 'initial' },
        },
        false
      );

      // Clear events
      emittedEvents.length = 0;

      // Replace data
      await store.replacePart(artifactId, 0, {
        kind: 'data',
        data: { state: 'updated' },
      });

      expect(emittedEvents).toHaveLength(1);
      const event = emittedEvents[0];

      expect(event.kind).toBe('data-write');
      if (event.kind === 'data-write') {
        expect(event.data).toEqual({ state: 'updated' });
      }
    });
  });

  describe('Mixed Content', () => {
    it('should emit appropriate events for mixed artifact parts', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-8',
        taskId: 'task-8',
        contextId: 'ctx-8',
        name: 'mixed-artifact',
      });

      // Append text part
      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'Text content',
        },
        false
      );

      // Append data part
      await store.appendPart(
        artifactId,
        {
          kind: 'data',
          data: { metadata: 'value' },
        },
        false
      );

      // Append another text part
      await store.appendPart(
        artifactId,
        {
          kind: 'text',
          content: 'More text',
        },
        true
      );

      expect(emittedEvents).toHaveLength(3);

      // First event: file-write
      expect(emittedEvents[0].kind).toBe('file-write');

      // Second event: data-write
      expect(emittedEvents[1].kind).toBe('data-write');

      // Third event: file-write
      expect(emittedEvents[2].kind).toBe('file-write');
    });
  });

  describe('Replace Parts', () => {
    it('should emit events when replacing all parts', async () => {
      const artifactId = await store.createArtifact({
        artifactId: 'art-9',
        taskId: 'task-9',
        contextId: 'ctx-9',
      });

      // Add initial parts
      await store.appendPart(artifactId, { kind: 'text', content: 'Part 1' }, false);
      await store.appendPart(artifactId, { kind: 'text', content: 'Part 2' }, true);

      // Clear events
      emittedEvents.length = 0;

      // Replace all parts
      await store.replaceParts(
        artifactId,
        [
          { kind: 'text', content: 'New Part 1' },
          { kind: 'text', content: 'New Part 2' },
        ],
        true
      );

      // Should emit 2 file-write events
      expect(emittedEvents).toHaveLength(2);
      expect(emittedEvents[0].kind).toBe('file-write');
      expect(emittedEvents[1].kind).toBe('file-write');

      if (emittedEvents[0].kind === 'file-write') {
        expect(emittedEvents[0].data).toBe('New Part 1');
      }
      if (emittedEvents[1].kind === 'file-write') {
        expect(emittedEvents[1].data).toBe('New Part 2');
      }
    });
  });

  describe('Event Emission Control', () => {
    it('should not emit events when enableEvents is false', async () => {
      const storeNoEvents = new InternalEventArtifactStore({
        delegate,
        eventEmitter,
        enableEvents: false,
      });

      const artifactId = await storeNoEvents.createArtifact({
        artifactId: 'art-10',
        taskId: 'task-10',
        contextId: 'ctx-10',
      });

      await storeNoEvents.appendPart(artifactId, { kind: 'text', content: 'Test' }, true);

      expect(emittedEvents).toHaveLength(0);
    });
  });

  describe('Error Handling', () => {
    it('should throw error if artifact not found when emitting events', async () => {
      await expect(
        store.appendPart('non-existent', { kind: 'text', content: 'Test' }, true)
      ).rejects.toThrow('Artifact not found');
    });
  });
});
